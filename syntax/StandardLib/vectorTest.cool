class Vector inherits IO {
    data : Array[Int];     -- Underlying array storage
    count : Int;           -- Number of elements currently in the vector
    capacity : Int;        -- Total capacity of the current array

    -- Initialize a new Vector with default initial capacity of 8
    init() : SELF_TYPE {
        {
            data <- new Array[Int](8);
            capacity <- 8;
            count <- 0;
            self;
        }
    };

    -- Initialize a Vector with a specific initial capacity
    init_capacity(initial_capacity : Int) : SELF_TYPE {
        {
            data <- new Array[Int](initial_capacity);
            capacity <- initial_capacity;
            count <- 0;
            self;
        }
    };

    -- Return the number of elements in the vector
    size() : Int {
        count
    };

    -- Return the first element of the vector
    -- Exits with error message if vector is empty
    front() : Int {
        if count = 0 then
            {
                out_string("Error: Vector is empty, cannot get front element\n");
                0; -- Return a default value for empty vector
            }
        else
            data[0]
        fi
    };

    -- Get element at specified index
    -- Returns -1 if index is out of bounds
    get(index : Int) : Int {
        if index < 0 then
            {
                out_string("Error: Index cannot be negative\n");
                ~1; -- Return -1 to indicate error
            }
        else if count <= index then
            {
                out_string("Error: Index out of bounds\n");
                ~1; -- Return -1 to indicate error
            }
        else{
            data[index]
        }
            
        fi fi
    };

    -- Set element at specified index
    -- Returns self if successful, prints error otherwise
    set(index : Int, value : Int) : SELF_TYPE {
        if index < 0 then
            {
                out_string("Error: Index cannot be negative\n");
                self;
            }
        else if count <= index then
            {
                out_string("Error: Index out of bounds\n");
                self;
            }
        else
            {
                data[index] <- value;
                self;
            }
        fi fi
    };

    -- Add an element to the end of the vector
    -- Resize if necessary
    push(value : Int) : SELF_TYPE {
        {
            -- Check if we need to resize
            if count = capacity then
                resize(capacity * 2)
            else
                self
            fi;

            -- Add the new element and increment count
            data[count] <- value;
            count <- count + 1;
            self;
        }
    };

    -- Remove and return the last element from the vector
    -- Returns -1 if vector is empty
    pop() : Int {
        let last_value : Int in {
            if count = 0 then
                {
                    out_string("Error: Vector is empty, cannot pop\n");
                    ~1; -- Return -1 to indicate error
                }
            else
                {
                    -- Decrement count and get the last value
                    count <- count - 1;
                    last_value <- data[count];

                    -- Check if we should shrink the array
                    -- Only shrink if we're at less than 25% capacity and capacity > 8
                    if count < (capacity / 4) then
                        if capacity < 8 then
                            self
                        else
                            resize(capacity / 2)
                        fi
                    else
                        self
                    fi;

                    last_value;
                }
            fi;
        }
    };

    -- Resize the underlying array to the new capacity
    -- This is an internal method used for growing and shrinking
    resize(new_capacity : Int) : SELF_TYPE {
        let new_array : Array[Int] <- new Array[Int](new_capacity),
            i : Int <- 0
        in {
            -- Copy all current elements to the new array
            while i < count loop {
                new_array[i] <- data[i];
                i <- i + 1;
            } pool;

            -- Replace the data array and update capacity
            data <- new_array;
            capacity <- new_capacity;
            self;
        }
    };

    -- Print the vector contents for debugging
    print() : SELF_TYPE {
        let i : Int <- 0 in {
            out_string("Vector[");
            while i < count loop {
                out_int(data[i]);
                if i < count - 1 then
                    out_string(", ")
                else
                    out_string("")
                fi;
                i <- i + 1;
            } pool;
            out_string("]\n");
            self;
        }
    };

    -- Check if the vector is empty
    is_empty() : Bool {
        count = 0
    };
};

class Main inherits IO {


    main() : Object {
        let v : Vector <- new Vector.init(),
            result : Int
        in {
            -- Test pushing elements
            out_string("Testing push operation:\n");
            v.push(10).push(20).push(30).push(40).push(50);
            v.push(10).push(20).push(30).push(40).push(50);
            v.push(10).push(20).push(30).push(40).push(50);
            v.print();
            
             -- Test size
            out_string("Vector size: ");
            out_int(v.size());
            out_string("\n");


            -- Test front
            out_string("Front element: ");
            result <- v.front();
            if v.is_empty() = false then
                out_int(result)
            else
                out_string("Error retrieving front element")
            fi;
            out_string("\n");



            -- Test get with error handling
            out_string("Element at position 2: ");
            result <- v.get(1);
            out_int(result);
            out_string("\n");

            -- Test set
            out_string("Setting index 1 to 99\n");
            v.set(1, 99);
            v.print();


            -- Test pop with error handling
            out_string("Popping last element: ");
            result <- v.pop();
            if result = ~1 then
                out_string("Error popping element")
            else
                out_int(result)
            fi;
            out_string("\n");
            v.print();


            -- Test invalid operations
            out_string("\nTesting error handling:\n");
            out_string("Getting element at index 100: ");
            result <- v.get(100);
            if result = ~1 then
                out_string("Error handled correctly\n")
            else
                out_string("Unexpected result\n")
            fi;


            -- Test resizing by pushing many elements
            out_string("\nTesting automatic resize by pushing more elements\n");
            v.push(60).push(70).push(80).push(90).push(100);
            v.push(110).push(120).push(130).push(140).push(150);
            v.push(60).push(70).push(80).push(90).push(100);
            v.push(110).push(120).push(130).push(140).push(150);
            v.print();


            -- Test resizing by popping many elements
            out_string("Testing automatic resize by popping elements\n");
            v.pop();v.pop();v.pop();v.pop();v.pop();v.pop();v.pop();v.pop();v.pop();v.pop();v.pop();
            v.print();

        }
    };
};